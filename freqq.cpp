#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#define BAUD 57600
#define BAUDRATE ((F_CPU)/(BAUD*16UL)-1)
#include <stdlib.h>
#include <stdio.h>
#define TIMER_FREQ  F_CPU/1024.0
#define TOTAL_COUNTS  65535
#define INIT_COUNT(x)  (TOTAL_COUNTS - (x)*TIMER_FREQ)
#define MAX_GATE 4.194
#define OVERFLOW(y)  (unsigned int)((y)/MAX_GATE)

// There exist a limit to the gate value to avoid TIMER5'S reset. TCNT5 cannot overcome 65535 in the gate time.

float gate = 30;  //in seconds 

	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Serial Communication inicialization 
void uart_init(void)
{
	UBRR0H = (BAUDRATE >> 8);
	UBRR0L = BAUDRATE;
	UCSR0B |= (1 << TXEN0)|(1 << RXEN0);
	UCSR0C |= (1<<UCSZ01)|(1<<UCSZ00);
}

//Function to send data
void uart_transmit(unsigned char data)
{
    while (!( UCSR0A & (1<<UDRE0)));                // wait while register is free
    UDR0 = data;                                   // load data in the register
}

//Function to receive data
unsigned char uart_recieve (void)
{

    while(!(UCSR0A & 1<<RXC0));                   // wait while data is being received
    return UDR0;                                   // return 8-bit data
}

int uart_send(char *data)
{
int i=0;
char c;
while ((c=data[i++])!='\0')
	uart_transmit(c);
	uart_transmit('\r');
	uart_transmit('\n');
return 1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	

int tot_overflow;
char msg[100];
double freq;
int count = 0;

void timer5_init()
{
	TCCR5B |= (1 << CS52)|(1 << CS51);
	TCNT5 = 0;
}

void timer3_init()
{
	TCCR3B |= (1 << CS32)|(1 << CS30);
	tot_overflow = OVERFLOW(gate);
	TCNT3 = INIT_COUNT(gate-MAX_GATE*OVERFLOW(gate))*(tot_overflow==0);
	TIMSK3 |= (1 << TOIE3);
	sei();
	tot_overflow--;
}


ISR(TIMER3_OVF_vect)
{
	TCNT3 = INIT_COUNT(gate-MAX_GATE*OVERFLOW(gate))*(tot_overflow==0);
	if(tot_overflow<0)
	{
		freq = (float)((TCNT5)/gate);
		TCNT5=0;
		dtostrf(freq,6, 3, (char*)msg);
		uart_send("----------");
		uart_send(msg);
		uart_send("----------");
		tot_overflow=OVERFLOW(gate);
	}
	tot_overflow--;

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int main()
{
	timer5_init();
	timer3_init();
	while(1){}
	return 0;
}